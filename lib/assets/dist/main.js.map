{
  "version": 3,
  "sources": ["../main.js"],
  "sourcesContent": ["export async function init(ctx, html) {\n  ctx.importCSS(\"main.css\");\n  ctx.root.innerHTML = html;\n  await ctx.importJS(\n    \"https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.js\"\n  );\n\n  const iceConf = {\n    iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }],\n  };\n\n  async function run() {\n    console.log(\"Starting.....\");\n    let stream = await window.navigator.mediaDevices.getUserMedia({\n      video: { width: 300, height: 300 },\n      audio: false,\n    });\n\n    // display the webcam in a <video> tag\n    const videoIn = document.getElementById(\"source\");\n    videoIn.srcObject = stream;\n    await videoIn.play();\n\n    // -------------------face-api ------------------\n    await faceapi.nets.tinyFaceDetector.loadFromUri(\n      \"https://github.com/dwyl/webrtc-sfu-demo/blob/main/assets/model/\"\n    );\n\n    async function processFrames(video) {\n      const displaySize = {\n        width: video.width,\n        height: video.height,\n      };\n\n      let canvas = faceapi.createCanvasFromMedia(video);\n      faceapi.matchDimensions(canvas, displaySize);\n\n      async function drawAtVideoRate() {\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(video, 0, 0, displaySize.width, displaySize.height);\n        const detections = await faceapi.detectAllFaces(\n          video,\n          new faceapi.TinyFaceDetectorOptions()\n        );\n        const resizedDetections = faceapi.resizeResults(\n          detections,\n          displaySize\n        );\n        faceapi.draw.drawDetections(canvas, resizedDetections);\n        video.requestVideoFrameCallback(drawAtVideoRate);\n      }\n\n      video.requestVideoFrameCallback(drawAtVideoRate);\n      return canvas.captureStream(30); // 30 FPS\n    }\n\n    const transformedStream = await processFrames(videoIn);\n\n    //----------------------- WEBRTC-----------------------------\n    const pc = new RTCPeerConnection(iceConf);\n\n    // capture local MediaStream (from the webcam)\n    const tracks = transformedStream.getTracks();\n    tracks.forEach((track) => pc.addTrack(track, stream));\n\n    // send offer to any peer connected on the signaling channel\n    pc.onicecandidate = ({ candidate }) => {\n      if (candidate === null) {\n        return;\n      }\n      ctx.pushEvent(\"ice\", { candidate: candidate.toJSON(), type: \"ice\" });\n    };\n\n    // send offer to any peer connected on the signaling channel\n    pc.onnegotiationneeded = async () => {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      console.log(\"--> Offer created and sent\");\n      ctx.pushEvent(\"offer\", { sdp: offer });\n    };\n\n    // received from the remote peer (Elixir SFU server here) via UDP\n    pc.ontrack = ({ streams }) => {\n      console.log(\"--> Received remote track\");\n      const echo = document.querySelector(\"#echo\");\n      echo.srcObject = streams[0];\n    };\n\n    // received from the remote peer via signaling channel (Elixir server)\n    ctx.handleEvent(\"ice\", async ({ candidate }) => {\n      await pc.addIceCandidate(candidate);\n    });\n\n    ctx.handleEvent(\"answer\", async (msg) => {\n      console.log(\"--> handled Answer\");\n      await pc.setRemoteDescription(msg);\n    });\n\n    // internal WebRTC listener, for information or other action...\n    pc.onconnectionstatechange = () => {\n      console.log(\"~~> Connection state: \", pc.connectionState);\n    };\n  }\n\n  run();\n}\n"],
  "mappings": "MAAA,eAAsBA,EAAKC,EAAKC,EAAM,CACpCD,EAAI,UAAU,UAAU,EACxBA,EAAI,KAAK,UAAYC,EACrB,MAAMD,EAAI,SACR,oEACF,EAEA,IAAME,EAAU,CACd,WAAY,CAAC,CAAE,KAAM,8BAA+B,CAAC,CACvD,EAEA,eAAeC,GAAM,CACnB,QAAQ,IAAI,eAAe,EAC3B,IAAIC,EAAS,MAAM,OAAO,UAAU,aAAa,aAAa,CAC5D,MAAO,CAAE,MAAO,IAAK,OAAQ,GAAI,EACjC,MAAO,EACT,CAAC,EAGKC,EAAU,SAAS,eAAe,QAAQ,EAChDA,EAAQ,UAAYD,EACpB,MAAMC,EAAQ,KAAK,EAGnB,MAAM,QAAQ,KAAK,iBAAiB,YAClC,iEACF,EAEA,eAAeC,EAAcC,EAAO,CAClC,IAAMC,EAAc,CAClB,MAAOD,EAAM,MACb,OAAQA,EAAM,MAChB,EAEIE,EAAS,QAAQ,sBAAsBF,CAAK,EAChD,QAAQ,gBAAgBE,EAAQD,CAAW,EAE3C,eAAeE,GAAkB,CACfD,EAAO,WAAW,IAAI,EAC9B,UAAUF,EAAO,EAAG,EAAGC,EAAY,MAAOA,EAAY,MAAM,EACpE,IAAMG,EAAa,MAAM,QAAQ,eAC/BJ,EACA,IAAI,QAAQ,uBACd,EACMK,EAAoB,QAAQ,cAChCD,EACAH,CACF,EACA,QAAQ,KAAK,eAAeC,EAAQG,CAAiB,EACrDL,EAAM,0BAA0BG,CAAe,CACjD,CAEA,OAAAH,EAAM,0BAA0BG,CAAe,EACxCD,EAAO,cAAc,EAAE,CAChC,CAEA,IAAMI,EAAoB,MAAMP,EAAcD,CAAO,EAG/CS,EAAK,IAAI,kBAAkBZ,CAAO,EAGzBW,EAAkB,UAAU,EACpC,QAASE,GAAUD,EAAG,SAASC,EAAOX,CAAM,CAAC,EAGpDU,EAAG,eAAiB,CAAC,CAAE,UAAAE,CAAU,IAAM,CACjCA,IAAc,MAGlBhB,EAAI,UAAU,MAAO,CAAE,UAAWgB,EAAU,OAAO,EAAG,KAAM,KAAM,CAAC,CACrE,EAGAF,EAAG,oBAAsB,SAAY,CACnC,IAAMG,EAAQ,MAAMH,EAAG,YAAY,EACnC,MAAMA,EAAG,oBAAoBG,CAAK,EAClC,QAAQ,IAAI,4BAA4B,EACxCjB,EAAI,UAAU,QAAS,CAAE,IAAKiB,CAAM,CAAC,CACvC,EAGAH,EAAG,QAAU,CAAC,CAAE,QAAAI,CAAQ,IAAM,CAC5B,QAAQ,IAAI,2BAA2B,EACvC,IAAMC,EAAO,SAAS,cAAc,OAAO,EAC3CA,EAAK,UAAYD,EAAQ,CAAC,CAC5B,EAGAlB,EAAI,YAAY,MAAO,MAAO,CAAE,UAAAgB,CAAU,IAAM,CAC9C,MAAMF,EAAG,gBAAgBE,CAAS,CACpC,CAAC,EAEDhB,EAAI,YAAY,SAAU,MAAOoB,GAAQ,CACvC,QAAQ,IAAI,oBAAoB,EAChC,MAAMN,EAAG,qBAAqBM,CAAG,CACnC,CAAC,EAGDN,EAAG,wBAA0B,IAAM,CACjC,QAAQ,IAAI,yBAA0BA,EAAG,eAAe,CAC1D,CACF,CAEAX,EAAI,CACN",
  "names": ["init", "ctx", "html", "iceConf", "run", "stream", "videoIn", "processFrames", "video", "displaySize", "canvas", "drawAtVideoRate", "detections", "resizedDetections", "transformedStream", "pc", "track", "candidate", "offer", "streams", "echo", "msg"]
}
